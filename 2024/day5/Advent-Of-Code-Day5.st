Object subclass: #SolvePart1	instanceVariableNames: ''	classVariableNames: ''	package: 'Advent-Of-Code-Day5'!!SolvePart1 methodsFor: 'as yet unclassified' stamp: '12/7/2024 22:00'!solve: aFileName	| input stream string parts calculatePages |	input := aFileName asFileReference.	input isFile ifFalse: [input close. ^ self error: 'Incorrect filename'].	stream := input readStream.		string := stream upToEnd.	parts := string splitOn: Character lf.		calculatePages  := CalculatePages new init.	calculatePages input: parts.	^ calculatePages total! !Object subclass: #MyCounter	instanceVariableNames: 'value'	classVariableNames: ''	package: 'Advent-Of-Code-Day5'!!MyCounter methodsFor: 'initialization' stamp: '12/7/2024 17:48'!value	^ value! !!MyCounter methodsFor: 'initialization' stamp: '12/7/2024 17:48'!value: anInteger	value := anInteger ! !!MyCounter methodsFor: 'initialization' stamp: '12/7/2024 17:49'!init	"Method for initialization. Setting variables to some default values. For example 0."	value := 0! !!MyCounter methodsFor: 'initialization' stamp: '12/7/2024 17:51'!increment  "This method adds 1 to variable value."	self value: (value + 1)! !!MyCounter methodsFor: 'initialization' stamp: '12/7/2024 17:51'!decrement  "This method substracts 1 to variable value."	self value: (value - 1)! !Object subclass: #RuleFinder	instanceVariableNames: 'rules reverse_rules'	classVariableNames: ''	package: 'Advent-Of-Code-Day5'!!RuleFinder methodsFor: 'initialization' stamp: '12/7/2024 18:25'!init	rules := Dictionary new.! !!RuleFinder methodsFor: 'meta-object-protocol' stamp: '12/8/2024 00:38'!read: parts	"comment Reads the file reference and changes the #rule variable to hold a dict of lists and shi"	| result |		1 to: (parts size) do: [ :each |    	(parts at: each) isEmpty ifTrue: [ ^each ].		result := (parts at: each) splitOn: '|'.		self at: result first put: result last.		"self at: result last put: result first."	].! !!RuleFinder methodsFor: 'accessing' stamp: '12/7/2024 18:33'!rules	^ rules! !!RuleFinder methodsFor: 'accessing' stamp: '12/8/2024 00:42'!reverse_rules	^ reverse_rules! !!RuleFinder methodsFor: 'adding' stamp: '12/8/2024 00:20'!at: key put: val	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	(rules includesKey: key)		ifTrue: [ (rules at: key) add: val ]		ifFalse: [ rules at: key put: (Set with: val) ].! !!RuleFinder methodsFor: 'adding' stamp: '12/8/2024 00:42'!reverse_at: key put: val	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	(reverse_rules includesKey: key)		ifTrue: [ (reverse_rules at: key) add: val ]		ifFalse: [ reverse_rules at: key put: (Set with: val) ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RuleFinder class	instanceVariableNames: 'aFileName'!Object subclass: #CalculatePages	instanceVariableNames: 'total ruleFinder'	classVariableNames: ''	package: 'Advent-Of-Code-Day5'!!CalculatePages methodsFor: 'initialization' stamp: '12/7/2024 22:35'!init	ruleFinder := RuleFinder new init.	total :=  0.! !!CalculatePages methodsFor: 'initialization' stamp: '12/7/2024 21:47'!total	^ total! !!CalculatePages methodsFor: 'initialization' stamp: '12/7/2024 21:48'!total: anInteger	total := anInteger ! !!CalculatePages methodsFor: 'initialization' stamp: '12/8/2024 00:00'!readin: parts	ruleFinder read: parts! !!CalculatePages methodsFor: 'adding' stamp: '12/7/2024 21:49'!add: anInteger  "This method substracts 1 to variable value."	self total: (total + anInteger)! !!CalculatePages methodsFor: 'checking' stamp: '12/8/2024 00:45'!orderComparison: anOrderedCollection	| list |		((ruleFinder rules) includesKey: (anOrderedCollection first)) ifTrue: 		[list := (ruleFinder rules at: (anOrderedCollection first)).		2 to: (anOrderedCollection size) do: [ :each |			(list includes: (anOrderedCollection at: each)) ifFalse: [ ^ false ].		]]		ifFalse: [ 	((ruleFinder reverse_rules) includesKey: (anOrderedCollection last)) ifTrue:	[list := (ruleFinder rules at: (anOrderedCollection last)).	1 to: ((anOrderedCollection size)-1) do: [ :each |		(list includes: (anOrderedCollection at: each)) ifFalse: [ ^ false ].	].].].	^ true! !!CalculatePages methodsFor: 'checking' stamp: '12/7/2024 23:05'!input: parts	"balls"	(ruleFinder read: parts) + 1 to: (parts size) do: [ :each |    	(parts at: each) isEmpty ifTrue: [ ^ each ].		self add: (self check: ((parts at: each) splitOn: ',')).	]! !!CalculatePages methodsFor: 'checking' stamp: '12/7/2024 23:51'!check: anOrderedCollection	1 to: (anOrderedCollection size) do: [ :each |		(self orderComparison: 		(anOrderedCollection copyFrom: each to: (anOrderedCollection size)))			ifFalse: [ ^ 0 ].	].	^ (anOrderedCollection at: (((anOrderedCollection size) / 2) ceiling)) asNumber! !